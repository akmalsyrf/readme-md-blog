---
import ChatButton from './ChatButton.astro';
import ChatWindow from './ChatWindow.astro';
import { translations, type Locale } from '../../utils/i18n';

interface Props {
  locale?: Locale;
}

const { locale = 'id' } = Astro.props;
---

<div id="chatbot-container" class="chatbot-container">
  <ChatButton locale={locale} />
  <ChatWindow locale={locale} />
</div>

<!-- Load marked library -->
<script type="module">
  import { marked } from 'https://cdn.jsdelivr.net/npm/marked@17.0.1/+esm';

  // Configure marked
  marked.setOptions({
    breaks: true,
    gfm: true,
  });

  // Make marked available globally
  // @ts-ignore
  window.marked = marked;
</script>

<script
  define:vars={{
    locale,
    translations: {
      id: {
        welcome: translations.id.chatbot.welcome,
        placeholder: translations.id.chatbot.placeholder,
        send: translations.id.chatbot.send,
        processing: translations.id.chatbot.processing,
        sources: translations.id.chatbot.sources,
        error: translations.id.chatbot.error,
        errorMessage: translations.id.chatbot.errorMessage,
        generatingRecommendations: translations.id.chatbot.generatingRecommendations,
        recommendations: translations.id.chatbot.recommendations,
      },
      en: {
        welcome: translations.en.chatbot.welcome,
        placeholder: translations.en.chatbot.placeholder,
        send: translations.en.chatbot.send,
        processing: translations.en.chatbot.processing,
        sources: translations.en.chatbot.sources,
        error: translations.en.chatbot.error,
        errorMessage: translations.en.chatbot.errorMessage,
        generatingRecommendations: translations.en.chatbot.generatingRecommendations,
        recommendations: translations.en.chatbot.recommendations,
      },
    },
  }}
>
  const t = translations[locale];

  // Get DOM elements
  const container = document.getElementById('chatbot-container');
  const toggle = document.getElementById('chatbot-toggle');
  const closeBtn = document.getElementById('chatbot-close');
  const window = document.getElementById('chatbot-window');
  const icon = document.getElementById('chatbot-icon');
  const form = document.getElementById('chatbot-form');
  const input = document.getElementById('chatbot-input');
  const submitBtn = document.getElementById('chatbot-submit');
  const messagesContainer = document.getElementById('chatbot-messages');
  const recommendationsContainer = document.getElementById('chatbot-recommendations');

  if (
    !container ||
    !toggle ||
    !closeBtn ||
    !window ||
    !icon ||
    !form ||
    !input ||
    !submitBtn ||
    !messagesContainer ||
    !recommendationsContainer
  ) {
    // eslint-disable-next-line no-console
    console.error('ChatBot: Required DOM elements not found');
  } else {
    // Storage keys
    const STORAGE_KEY = 'chatbot_history';
    const STORAGE_STATE_KEY = 'chatbot_state';

    // Check if this is a full page refresh (not navigation)
    const checkNavigationType = () => {
      try {
        const navEntries = performance.getEntriesByType('navigation');
        if (navEntries && navEntries.length > 0) {
          const navEntry = navEntries[0];
          return navEntry.type; // 'reload', 'navigate', 'back_forward', etc.
        }
      } catch (error) {
        // Fallback
      }
      return 'navigate'; // Default to navigate
    };

    // Helper function to render markdown (needed by addMessageToDOM)
    const renderMarkdown = (text) => {
      try {
        // Use marked from window if available
        // @ts-ignore
        if (typeof window !== 'undefined' && window.marked) {
          // @ts-ignore
          return window.marked.parse(text);
        }

        // Enhanced fallback: better markdown parsing
        let html = text;

        // Split into lines for better processing
        const lines = html.split('\n');
        const processedLines = [];
        let inList = false;
        let listType = null; // 'ol' or 'ul'
        let listItems = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();

          // Check for numbered list: "1. text"
          const numberedMatch = line.match(/^(\d+)\.\s+(.+)$/);
          if (numberedMatch) {
            if (!inList || listType !== 'ol') {
              if (inList && listItems.length > 0) {
                processedLines.push(`<${listType}>${listItems.join('')}</${listType}>`);
                listItems = [];
              }
              inList = true;
              listType = 'ol';
            }
            listItems.push(`<li>${numberedMatch[2]}</li>`);
            continue;
          }

          // Check for bullet list: "- text" or "* text"
          const bulletMatch = line.match(/^[-*]\s+(.+)$/);
          if (bulletMatch) {
            if (!inList || listType !== 'ul') {
              if (inList && listItems.length > 0) {
                processedLines.push(`<${listType}>${listItems.join('')}</${listType}>`);
                listItems = [];
              }
              inList = true;
              listType = 'ul';
            }
            listItems.push(`<li>${bulletMatch[1]}</li>`);
            continue;
          }

          // Not a list item - close list if open
          if (inList) {
            processedLines.push(`<${listType}>${listItems.join('')}</${listType}>`);
            listItems = [];
            inList = false;
            listType = null;
          }

          // Regular line
          if (line) {
            processedLines.push(line);
          } else {
            processedLines.push('');
          }
        }

        // Close any open list
        if (inList && listItems.length > 0) {
          processedLines.push(`<${listType}>${listItems.join('')}</${listType}>`);
        }

        html = processedLines.join('\n');

        // Bold: **text**
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

        // Italic: *text* (but not **text**)
        html = html.replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, '<em>$1</em>');

        // Inline code: `code`
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

        // Paragraphs: split by double newlines
        const paragraphs = html.split(/\n\n+/);
        html = paragraphs
          .map((p) => {
            p = p.trim();
            if (!p) return '';
            if (!p.startsWith('<')) {
              return '<p>' + p + '</p>';
            }
            return p;
          })
          .join('\n');

        // Single line breaks
        html = html.replace(/\n/g, '<br>');

        return html;
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error parsing markdown:', error);
        return text; // Fallback to plain text
      }
    };

    // Update or create streaming message
    let currentStreamingMessage = null;
    let currentThinkingContainer = null;
    let currentAnswerContainer = null;

    const createStreamingMessage = () => {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'flex items-start space-x-2 mb-6';
      messageDiv.id = 'chatbot-streaming-message';

      const avatar = document.createElement('div');
      avatar.className =
        'flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900';
      avatar.innerHTML = `
        <svg class="h-5 w-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
        </svg>
      `;
      messageDiv.appendChild(avatar);

      const contentDiv = document.createElement('div');
      contentDiv.className = 'flex-1 rounded-lg px-4 py-3 bg-gray-100 dark:bg-gray-700';

      // Thinking container
      const thinkingContainer = document.createElement('div');
      thinkingContainer.className = 'mb-3 chatbot-thinking-container';
      thinkingContainer.style.display = 'none';
      contentDiv.appendChild(thinkingContainer);

      // Answer container
      const answerContainer = document.createElement('div');
      answerContainer.className =
        'prose prose-sm prose-slate max-w-none dark:prose-invert chatbot-answer-container';
      contentDiv.appendChild(answerContainer);

      messageDiv.appendChild(contentDiv);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;

      currentStreamingMessage = messageDiv;
      currentThinkingContainer = thinkingContainer;
      currentAnswerContainer = answerContainer;

      return { messageDiv, thinkingContainer, answerContainer };
    };

    const updateStreamingThinking = (text) => {
      // Ensure streaming message is created
      if (!currentStreamingMessage) {
        createStreamingMessage();
      }

      if (!currentThinkingContainer) {
        const { thinkingContainer } = createStreamingMessage();
        currentThinkingContainer = thinkingContainer;
      }

      // Show thinking container
      currentThinkingContainer.style.display = 'block';

      // Update or create thinking step
      let thinkingStep = currentThinkingContainer.querySelector('.chatbot-thinking-step-content');
      if (!thinkingStep) {
        // Create new thinking step container with icon
        const stepWrapper = document.createElement('div');
        stepWrapper.className =
          'flex items-start gap-2 mb-2 p-2 rounded bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800';

        // Add thinking icon
        const icon = document.createElement('div');
        icon.className =
          'flex h-4 w-4 shrink-0 items-center justify-center rounded-full bg-purple-200 dark:bg-purple-800 mt-0.5';
        icon.innerHTML = `
          <svg class="h-3 w-3 text-purple-600 dark:text-purple-400 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        `;
        stepWrapper.appendChild(icon);

        thinkingStep = document.createElement('p');
        thinkingStep.className =
          'text-xs text-purple-700 dark:text-purple-300 italic chatbot-thinking-step-content flex-1';
        stepWrapper.appendChild(thinkingStep);
        currentThinkingContainer.appendChild(stepWrapper);
      }

      // Update thinking text
      thinkingStep.textContent = text || 'Memproses...';
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    };

    const updateStreamingAnswer = (text) => {
      if (!currentAnswerContainer) {
        const { answerContainer } = createStreamingMessage();
        currentAnswerContainer = answerContainer;
      }

      const html = renderMarkdown(text);
      currentAnswerContainer.innerHTML = html;
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    };

    const finalizeStreamingMessage = (sources) => {
      if (!currentStreamingMessage) return;

      // Add sources if available
      if (sources && sources.length > 0) {
        const contentDiv = currentStreamingMessage.querySelector('.flex-1');
        const sourcesDiv = document.createElement('div');
        sourcesDiv.className = 'mt-3 border-t border-gray-300 pt-3 dark:border-gray-600';

        const sourcesTitle = document.createElement('p');
        sourcesTitle.className = 'mb-2 text-xs font-semibold text-gray-600 dark:text-gray-400';
        sourcesTitle.textContent = t.sources + ':';
        sourcesDiv.appendChild(sourcesTitle);

        const sourcesList = document.createElement('ul');
        sourcesList.className = 'space-y-1';
        sources.forEach((source) => {
          const sourceItem = document.createElement('li');
          sourceItem.className = 'text-xs text-gray-600 dark:text-gray-400';
          const link = document.createElement('a');
          link.href = `/${locale}/notes/${source.noteId}`;
          link.className = 'hover:text-blue-600 dark:hover:text-blue-400 underline';
          link.textContent = source.title;
          sourceItem.appendChild(link);
          sourcesList.appendChild(sourceItem);
        });
        sourcesDiv.appendChild(sourcesList);
        contentDiv.appendChild(sourcesDiv);
      }

      // Save to localStorage
      const answerText = currentAnswerContainer ? currentAnswerContainer.innerText : '';
      saveChatHistory(answerText, false, sources);
      saveChatState();

      // Reset streaming state
      currentStreamingMessage = null;
      currentThinkingContainer = null;
      currentAnswerContainer = null;
    };

    // Add message to DOM (internal function, can skip saving)
    const addMessageToDOM = (text, isUser = false, sources, saveToStorage = true) => {
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex items-start space-x-2 mb-6 ${isUser ? 'flex-row-reverse space-x-reverse' : ''}`;

      if (!isUser) {
        const avatar = document.createElement('div');
        avatar.className =
          'flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900';
        avatar.innerHTML = `
          <svg class="h-5 w-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        `;
        messageDiv.appendChild(avatar);
      }

      const contentDiv = document.createElement('div');
      contentDiv.className = `flex-1 rounded-lg px-4 py-3 ${
        isUser ? 'bg-blue-600 text-white' : 'bg-gray-100 dark:bg-gray-700'
      }`;

      // Render markdown for bot messages, plain text for user messages
      if (!isUser) {
        // Render markdown to HTML for bot responses
        // Use Tailwind Typography (same as BlogPostContent) but smaller size
        const markdownContent = document.createElement('div');
        markdownContent.className = 'prose prose-sm prose-slate max-w-none dark:prose-invert';

        // Parse markdown synchronously
        const html = renderMarkdown(text);
        markdownContent.innerHTML = html;
        contentDiv.appendChild(markdownContent);
      } else {
        // User messages remain as plain text
        const textP = document.createElement('p');
        textP.className = 'text-sm text-white';
        textP.textContent = text;
        contentDiv.appendChild(textP);
      }

      // Add sources if available
      if (sources && sources.length > 0) {
        const sourcesDiv = document.createElement('div');
        sourcesDiv.className = 'mt-3 border-t border-gray-300 pt-3 dark:border-gray-600';

        const sourcesTitle = document.createElement('p');
        sourcesTitle.className = 'mb-2 text-xs font-semibold text-gray-600 dark:text-gray-400';
        sourcesTitle.textContent = t.sources + ':';
        sourcesDiv.appendChild(sourcesTitle);

        const sourcesList = document.createElement('ul');
        sourcesList.className = 'space-y-1';
        sources.forEach((source) => {
          const sourceItem = document.createElement('li');
          sourceItem.className = 'text-xs text-gray-600 dark:text-gray-400';
          const link = document.createElement('a');
          link.href = `/${locale}/notes/${source.noteId}`;
          link.className = 'hover:text-blue-600 dark:hover:text-blue-400 underline';
          link.textContent = source.title;
          sourceItem.appendChild(link);
          sourcesList.appendChild(sourceItem);
        });
        sourcesDiv.appendChild(sourcesList);
        contentDiv.appendChild(sourcesDiv);
      }

      messageDiv.appendChild(contentDiv);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;

      // Hide recommendations after first message
      if (!hasMessages) {
        hasMessages = true;
        recommendationsContainer.innerHTML = '';
      }

      // Save to localStorage if requested
      if (saveToStorage) {
        saveChatHistory(text, isUser, sources);
        saveChatState();
      }
    };

    // Load chat history from localStorage
    const loadChatHistory = () => {
      try {
        const savedHistory = localStorage.getItem(STORAGE_KEY);
        const savedState = localStorage.getItem(STORAGE_STATE_KEY);

        if (savedHistory) {
          const messages = JSON.parse(savedHistory);

          // Clear welcome message if we have saved messages
          if (messages.length > 0) {
            const welcomeMessage = messagesContainer.querySelector('.chatbot-message-bot');
            if (welcomeMessage) {
              welcomeMessage.remove();
            }

            // Restore messages
            messages.forEach((msg) => {
              addMessageToDOM(msg.text, msg.isUser, msg.sources, false); // false = don't save to storage
            });

            hasMessages = true;
            recommendationsContainer.innerHTML = '';
          }
        }

        // Restore chat window state
        if (savedState) {
          const state = JSON.parse(savedState);
          if (state.isOpen) {
            isOpen = true;
            window.classList.remove('hidden');
            window.style.display = 'flex';
            icon.classList.add('rotated');
          }
        }
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error loading chat history:', error);
      }
    };

    // Save chat history to localStorage
    const saveChatHistory = (text, isUser, sources) => {
      try {
        const existingHistory = localStorage.getItem(STORAGE_KEY);
        const messages = existingHistory ? JSON.parse(existingHistory) : [];

        messages.push({
          text,
          isUser,
          sources: sources || [],
          timestamp: Date.now(),
        });

        // Keep only last 50 messages to avoid storage limit
        const trimmedMessages = messages.slice(-50);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmedMessages));
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error saving chat history:', error);
      }
    };

    // Save chat state (isOpen)
    const saveChatState = () => {
      try {
        localStorage.setItem(
          STORAGE_STATE_KEY,
          JSON.stringify({
            isOpen,
            hasMessages,
          })
        );
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error saving chat state:', error);
      }
    };

    let isOpen = false;
    let hasMessages = false;

    // Check navigation type and clear history only on full page refresh
    const navType = checkNavigationType();
    if (navType === 'reload') {
      // Full page refresh - clear history
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(STORAGE_STATE_KEY);
    } else {
      // Navigation (not refresh) - load history
      loadChatHistory();
    }

    // Auto-resize textarea
    const autoResize = () => {
      input.style.height = 'auto';
      const maxHeight = 120; // ~3 rows
      input.style.height = Math.min(input.scrollHeight, maxHeight) + 'px';
    };

    // Load recommendations
    const loadRecommendations = async () => {
      if (hasMessages) return; // Don't load if already has conversation

      // Show loading state
      recommendationsContainer.innerHTML = `
        <div class="flex items-center space-x-2 text-sm text-gray-600 dark:text-gray-400">
          <svg class="h-4 w-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
          <span>${t.generatingRecommendations}</span>
        </div>
      `;

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            action: 'getRecommendations',
            locale,
          }),
        });

        if (response.ok) {
          const data = await response.json();
          if (data.recommendations && data.recommendations.length > 0) {
            displayRecommendations(data.recommendations);
          } else {
            recommendationsContainer.innerHTML = '';
          }
        } else {
          recommendationsContainer.innerHTML = '';
        }
      } catch (error) {
        // Silently fail - recommendations are optional
        recommendationsContainer.innerHTML = '';
      }
    };

    // Display recommendations
    const displayRecommendations = (recommendations) => {
      recommendationsContainer.innerHTML = `
        <div class="mb-2 text-xs font-semibold text-gray-600 dark:text-gray-400">
          ${t.recommendations}
        </div>
      `;

      recommendations.forEach((rec) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className =
          'w-full mb-2 text-left rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm text-gray-700 transition-colors hover:border-blue-500 hover:bg-blue-50 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-300 dark:hover:border-blue-500 dark:hover:bg-blue-900/20';
        button.textContent = rec;
        button.addEventListener('click', () => {
          input.value = rec;
          autoResize();
          form.dispatchEvent(new Event('submit'));
        });
        recommendationsContainer.appendChild(button);
      });
    };

    // Toggle chat window
    const toggleChat = () => {
      isOpen = !isOpen;
      if (isOpen) {
        window.classList.remove('hidden');
        window.style.display = 'flex';
        icon.classList.add('rotated');
        input.focus();
        autoResize();
        if (!hasMessages) {
          loadRecommendations();
        }
      } else {
        window.classList.add('hidden');
        window.style.display = 'none';
        icon.classList.remove('rotated');
      }
      saveChatState();
    };

    // Auto-resize on input
    input.addEventListener('input', autoResize);

    // Handle Enter key (Shift+Enter for new line, Enter to submit)
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        form.dispatchEvent(new Event('submit'));
      }
    });

    toggle.addEventListener('click', toggleChat);
    closeBtn.addEventListener('click', toggleChat);

    // Add message to chat (public function)
    const addMessage = (text, isUser = false, sources) => {
      addMessageToDOM(text, isUser, sources, true);
    };

    // Add loading indicator
    const addLoading = () => {
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'chatbot-loading';
      loadingDiv.className = 'flex items-start space-x-2 mb-6';
      loadingDiv.innerHTML = `
        <div class="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900">
          <svg class="h-5 w-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        </div>
        <div class="flex-1 rounded-lg bg-gray-100 px-4 py-3 dark:bg-gray-700">
          <p class="text-sm text-gray-700 dark:text-gray-300">${t.processing}</p>
        </div>
      `;
      messagesContainer.appendChild(loadingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    };

    // Remove loading indicator
    const removeLoading = () => {
      const loading = document.getElementById('chatbot-loading');
      if (loading) {
        loading.remove();
      }
    };

    // Get conversation history from localStorage for API
    const getConversationHistory = () => {
      try {
        const savedHistory = localStorage.getItem(STORAGE_KEY);
        if (!savedHistory) return [];

        const messages = JSON.parse(savedHistory);
        // Convert to API format: only include text and isUser flag
        // We'll convert isUser to role format
        return messages
          .map((msg) => ({
            role: msg.isUser ? 'user' : 'assistant',
            content: msg.text,
          }))
          .slice(-10); // Limit to last 10 messages
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error getting conversation history:', error);
        return [];
      }
    };

    // Handle form submission with streaming support
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const question = input.value.trim();
      if (!question) return;

      // Add user message
      addMessage(question, true);
      input.value = '';
      input.style.height = 'auto';
      submitBtn.disabled = true;
      submitBtn.textContent = t.processing;

      // Reset streaming state
      currentStreamingMessage = null;
      currentThinkingContainer = null;
      currentAnswerContainer = null;

      // Add loading indicator
      addLoading();

      try {
        // Get conversation history (before adding current question)
        const conversationHistory = getConversationHistory();

        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            question,
            locale,
            conversationHistory,
            stream: true, // Enable streaming
          }),
        });

        if (!response.ok) {
          removeLoading();
          const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
          throw new Error(errorData.message || errorData.error || t.errorMessage);
        }

        // Handle streaming response
        if (response.body) {
          // Create streaming message immediately and show processing state
          createStreamingMessage();
          if (currentThinkingContainer) {
            currentThinkingContainer.style.display = 'block';
            const thinkingStep = currentThinkingContainer.querySelector(
              '.chatbot-thinking-step-content'
            );
            if (!thinkingStep) {
              const stepWrapper = document.createElement('div');
              stepWrapper.className =
                'flex items-start gap-2 mb-2 p-2 rounded bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800';
              const icon = document.createElement('div');
              icon.className =
                'flex h-4 w-4 shrink-0 items-center justify-center rounded-full bg-purple-200 dark:bg-purple-800 mt-0.5';
              icon.innerHTML = `
                <svg class="h-3 w-3 text-purple-600 dark:text-purple-400 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                </svg>
              `;
              stepWrapper.appendChild(icon);
              const thinkingStepContent = document.createElement('p');
              thinkingStepContent.className =
                'text-xs text-purple-700 dark:text-purple-300 italic chatbot-thinking-step-content flex-1';
              thinkingStepContent.textContent = t.processing;
              stepWrapper.appendChild(thinkingStepContent);
              currentThinkingContainer.appendChild(stepWrapper);
            }
          }
          // Remove loading indicator now that streaming message is created
          removeLoading();

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          let done = false;
          let hasReceivedData = false;

          while (!done) {
            const result = await reader.read();
            done = result.done;
            if (done) break;
            const { value } = result;

            buffer += decoder.decode(value, { stream: true });

            // SSE events are separated by \n\n
            const events = buffer.split('\n\n');
            // Keep the last incomplete event in buffer
            buffer = events.pop() || '';

            for (const event of events) {
              if (!event.trim()) continue;

              // Find data line
              const lines = event.split('\n');
              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  try {
                    const jsonStr = line.slice(6).trim();
                    if (!jsonStr) continue;

                    const data = JSON.parse(jsonStr);

                    if (data.type === 'thinking') {
                      hasReceivedData = true;
                      updateStreamingThinking(data.content);
                    } else if (data.type === 'answer') {
                      hasReceivedData = true;
                      // Hide thinking when answer starts
                      if (currentThinkingContainer) {
                        currentThinkingContainer.style.display = 'none';
                      }
                      updateStreamingAnswer(data.content);
                    } else if (data.type === 'done') {
                      hasReceivedData = true;
                      // Hide thinking when done
                      if (currentThinkingContainer) {
                        currentThinkingContainer.style.display = 'none';
                      }
                      updateStreamingAnswer(data.content);
                      finalizeStreamingMessage(data.sources);
                    } else if (data.type === 'error') {
                      hasReceivedData = true;
                      removeLoading();
                      // Clean up streaming state on error
                      if (currentStreamingMessage) {
                        currentStreamingMessage.remove();
                        currentStreamingMessage = null;
                        currentThinkingContainer = null;
                        currentAnswerContainer = null;
                      }
                      addMessage(`${t.error}: ${data.content}`, false);
                    }
                  } catch (parseError) {
                    // Skip invalid JSON
                    // eslint-disable-next-line no-console
                    console.error('Error parsing SSE data:', parseError, line);
                  }
                }
              }
            }
          }

          // Process remaining buffer
          if (buffer.trim()) {
            const lines = buffer.split('\n');
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const jsonStr = line.slice(6).trim();
                  if (jsonStr) {
                    const data = JSON.parse(jsonStr);
                    hasReceivedData = true;
                    if (data.type === 'done') {
                      finalizeStreamingMessage(data.sources);
                    }
                  }
                } catch (parseError) {
                  // Ignore parse errors for incomplete data
                }
              }
            }
          }

          // If stream ended without receiving any data, show error
          if (!hasReceivedData && currentStreamingMessage) {
            currentStreamingMessage.remove();
            currentStreamingMessage = null;
            currentThinkingContainer = null;
            currentAnswerContainer = null;
            addMessage(`${t.error}: ${t.errorMessage}`, false);
          }
        } else {
          // Fallback to non-streaming if body is not available
          const data = await response.json();
          if (data.error) {
            addMessage(`${t.error}: ${data.message || data.error}`, false);
          } else {
            addMessage(data.answer || '', false, data.sources);
          }
        }
      } catch (error) {
        removeLoading();
        const errorMessage = error instanceof Error ? error.message : t.errorMessage;
        addMessage(`${t.error}: ${errorMessage}`, false);

        // Clean up streaming state on error
        if (currentStreamingMessage) {
          currentStreamingMessage.remove();
          currentStreamingMessage = null;
          currentThinkingContainer = null;
          currentAnswerContainer = null;
        }
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = t.send;
        input.focus();
      }
    });
  }
</script>

<style>
  .chatbot-container {
    @apply fixed bottom-6 right-6 z-50;
  }

  /* Mobile responsive styles */
  @media (max-width: 640px) {
    .chatbot-container {
      @apply bottom-4 right-4;
    }
  }

  /* Override prose spacing for chat context - make it more compact */
  .chatbot-messages .prose {
    @apply text-sm;
  }

  .chatbot-messages .prose p {
    @apply mb-2;
  }

  .chatbot-messages .prose p:last-child {
    @apply mb-0;
  }

  .chatbot-messages .prose h1,
  .chatbot-messages .prose h2,
  .chatbot-messages .prose h3,
  .chatbot-messages .prose h4 {
    @apply mb-2 mt-2;
  }

  .chatbot-messages .prose h1 {
    @apply text-lg;
  }

  .chatbot-messages .prose h2 {
    @apply text-base;
  }

  .chatbot-messages .prose h3 {
    @apply text-sm;
  }

  .chatbot-messages .prose h4 {
    @apply text-sm;
  }

  .chatbot-messages .prose ul,
  .chatbot-messages .prose ol {
    @apply mb-2;
  }

  .chatbot-messages .prose li {
    @apply mb-1;
  }

  .chatbot-messages .prose pre {
    @apply mb-2 mt-2 text-xs;
  }

  .chatbot-messages .prose blockquote {
    @apply my-2 mb-2;
  }

  .chatbot-messages .prose hr {
    @apply my-2;
  }

  .chatbot-messages .prose table {
    @apply mb-2 text-xs;
  }

  /* Thinking process styles */
  .chatbot-thinking-step {
    animation: fadeIn 0.3s ease-in;
  }

  .chatbot-thinking-container {
    animation: fadeIn 0.3s ease-in;
  }

  .chatbot-thinking-container > div {
    animation: slideInLeft 0.3s ease-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  @keyframes slideInLeft {
    from {
      opacity: 0;
      transform: translateX(-10px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  /* Smooth transitions for streaming content */
  .chatbot-answer-container {
    animation: fadeIn 0.2s ease-in;
  }
</style>
