---
import type { Locale } from '../../../utils/i18n';
import { translations } from '../../../utils/i18n';
import { STORAGE_KEYS } from '../../../utils/storageConfig';
import DeepResearchFocusSelect from './DeepResearchFocusSelect.astro';

interface Props {
  locale: Locale;
  t: any;
  apiEndpoint?: string;
}

// Get API endpoint from env variable
const apiBaseUrl = (
  import.meta.env.API_DEEP_RESEARCH_BASE_URL ||
  process.env.API_DEEP_RESEARCH_BASE_URL ||
  ''
).trim();
const defaultApiBaseUrl = apiBaseUrl || 'https://api-deep-research-backend.vercel.app';
const defaultApiEndpoint = `${defaultApiBaseUrl}/research`;

const { locale, t, apiEndpoint = defaultApiEndpoint } = Astro.props;
---

<div
  id="deep-research-chat"
  class="flex h-[calc(100vh-12rem)] min-h-[400px] flex-col rounded-lg border border-gray-200 bg-white shadow-lg dark:border-gray-700 dark:bg-gray-800 sm:min-h-[600px]"
>
  <!-- Chat Header -->
  <div
    class="flex flex-col gap-3 border-b border-gray-200 px-4 py-3 dark:border-gray-700 sm:flex-row sm:items-center sm:justify-between sm:gap-0 sm:px-6 sm:py-4"
  >
    <div class="flex min-w-0 items-center gap-2 sm:gap-3">
      <div
        class="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-gradient-to-r from-purple-500 to-pink-500 sm:h-10 sm:w-10"
      >
        <svg
          class="h-4 w-4 text-white sm:h-6 sm:w-6"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
          ></path>
        </svg>
      </div>
      <div class="min-w-0 flex-1">
        <h2 class="truncate text-base font-semibold text-gray-900 dark:text-gray-100 sm:text-lg">
          {t.deepResearchChat.title}
        </h2>
        <p class="truncate text-xs text-gray-500 dark:text-gray-400">
          {t.deepResearchChat.subtitle}
        </p>
      </div>
    </div>
    <div class="flex flex-wrap items-center gap-2">
      <span
        class="inline-flex items-center whitespace-nowrap rounded-full bg-amber-500 px-2 py-0.5 text-xs font-semibold text-white shadow-sm"
      >
        {t.deepResearchChat.underConstruction || 'Under Construction'}
      </span>
      <span
        class="inline-flex items-center whitespace-nowrap rounded-full bg-gradient-to-r from-purple-500 to-pink-500 px-2 py-0.5 text-xs font-semibold text-white shadow-sm"
      >
        {t.others.experimental}
      </span>
    </div>
  </div>

  <!-- Messages Container -->
  <div
    id="deep-research-messages"
    class="flex-1 space-y-3 overflow-y-auto px-3 py-3 sm:space-y-4 sm:px-6 sm:py-4"
  >
    <!-- Welcome Message -->
    <div class="flex items-start space-x-2 sm:space-x-3">
      <div
        class="flex h-7 w-7 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900 sm:h-8 sm:w-8"
      >
        <svg
          class="h-4 w-4 text-blue-600 dark:text-blue-400 sm:h-5 sm:w-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
          ></path>
        </svg>
      </div>
      <div class="flex-1 rounded-lg bg-gray-100 px-3 py-2 dark:bg-gray-700 sm:px-4 sm:py-3">
        <p class="text-xs text-gray-700 dark:text-gray-300 sm:text-sm">
          {t.deepResearchChat.welcome}
        </p>
      </div>
    </div>
  </div>

  <!-- Input Container -->
  <div class="border-t border-gray-200 px-3 py-3 dark:border-gray-700 sm:px-6 sm:py-4">
    <form id="deep-research-form" class="flex gap-2 sm:gap-3">
      <div class="flex flex-1 gap-2 sm:gap-3">
        <DeepResearchFocusSelect locale={locale} apiBaseUrl={defaultApiBaseUrl} />
        <textarea
          id="deep-research-input"
          rows="1"
          placeholder={t.deepResearchChat.placeholder}
          class="flex-1 resize-none rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-purple-500 focus:outline-none focus:ring-2 focus:ring-purple-500/20 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100 dark:placeholder-gray-400 sm:px-4 sm:py-2"
        ></textarea>
      </div>
      <button
        type="submit"
        id="deep-research-submit"
        class="flex h-11 w-11 shrink-0 touch-manipulation items-center justify-center rounded-lg bg-gradient-to-r from-purple-500 to-pink-500 text-white transition-colors hover:from-purple-600 hover:to-pink-600 disabled:opacity-50 sm:h-10 sm:w-10"
      >
        <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
        </svg>
      </button>
    </form>
  </div>
</div>

<!-- Load marked library -->
<script type="module">
  import { marked } from 'https://cdn.jsdelivr.net/npm/marked@17.0.1/+esm';
  marked.setOptions({ breaks: true, gfm: true });
  // @ts-ignore
  window.marked = marked;
</script>

<!-- Load deep research utilities -->
<script type="module">
  // Deep Research API utility functions
  const parseSSELine = (line) => {
    const trimmedLine = line.trim();
    if (!trimmedLine) return null;
    let jsonLine = trimmedLine;
    if (jsonLine.startsWith('data: ')) {
      jsonLine = jsonLine.substring(6);
    }
    if (!jsonLine || jsonLine.startsWith(':') || jsonLine === '' || jsonLine.startsWith('event:')) {
      return null;
    }
    return jsonLine;
  };

  const parseStreamChunk = (jsonLine) => {
    try {
      return JSON.parse(jsonLine);
    } catch {
      return null;
    }
  };

  const validateResponse = async (response) => {
    if (!response.ok) {
      const errorText = await response.text();
      let errorData;
      try {
        errorData = JSON.parse(errorText);
      } catch {
        errorData = { message: errorText || 'Unknown error occurred' };
      }
      throw new Error(errorData.message || errorData.error || 'Unknown error occurred');
    }
    if (!response.body) {
      throw new Error('Response body is empty');
    }
  };

  const createDeepResearchRequest = async (apiEndpoint, request) => {
    const response = await fetch(apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });
    await validateResponse(response);
    return response;
  };

  const processStreamingResponse = async (response, onChunk) => {
    if (!response.body) {
      throw new Error('Response body is empty');
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let hasReceivedData = false;
    try {
      // eslint-disable-next-line no-constant-condition
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        hasReceivedData = true;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';
        for (const line of lines) {
          const jsonLine = parseSSELine(line);
          if (!jsonLine) continue;
          const chunk = parseStreamChunk(jsonLine);
          if (chunk) {
            onChunk(chunk);
          }
        }
      }
      if (!hasReceivedData) {
        throw new Error('No data received from server');
      }
    } finally {
      reader.releaseLock();
    }
  };

  // Expose utilities globally
  // @ts-ignore
  window.deepResearchUtils = {
    createDeepResearchRequest,
    processStreamingResponse,
  };
</script>

<!-- Load deep research utilities -->
<script type="module">
  // Deep Research API utility functions (inline to avoid import issues in client-side)
  const parseSSELine = (line) => {
    const trimmedLine = line.trim();
    if (!trimmedLine) return null;
    let jsonLine = trimmedLine;
    if (jsonLine.startsWith('data: ')) {
      jsonLine = jsonLine.substring(6);
    }
    if (!jsonLine || jsonLine.startsWith(':') || jsonLine === '' || jsonLine.startsWith('event:')) {
      return null;
    }
    return jsonLine;
  };

  const parseStreamChunk = (jsonLine) => {
    try {
      return JSON.parse(jsonLine);
    } catch {
      return null;
    }
  };

  const validateResponse = async (response) => {
    if (!response.ok) {
      const errorText = await response.text();
      let errorData;
      try {
        errorData = JSON.parse(errorText);
      } catch {
        errorData = { message: errorText || 'Unknown error occurred' };
      }
      throw new Error(errorData.message || errorData.error || 'Unknown error occurred');
    }
    if (!response.body) {
      throw new Error('Response body is empty');
    }
  };

  const createDeepResearchRequest = async (apiEndpoint, request) => {
    const response = await fetch(apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });
    await validateResponse(response);
    return response;
  };

  const processStreamingResponse = async (response, onChunk) => {
    if (!response.body) {
      throw new Error('Response body is empty');
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let hasReceivedData = false;
    try {
      // eslint-disable-next-line no-constant-condition
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        hasReceivedData = true;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';
        for (const line of lines) {
          const jsonLine = parseSSELine(line);
          if (!jsonLine) continue;
          const chunk = parseStreamChunk(jsonLine);
          if (chunk) {
            onChunk(chunk);
          }
        }
      }
      if (!hasReceivedData) {
        throw new Error('No data received from server');
      }
    } finally {
      reader.releaseLock();
    }
  };

  // Expose utilities globally
  // @ts-ignore
  window.deepResearchUtils = {
    createDeepResearchRequest,
    processStreamingResponse,
  };
</script>

<script
  define:vars={{
    locale,
    apiEndpoint,
    storageKeys: {
      chatHistory: STORAGE_KEYS.DEEP_RESEARCH_CHAT_HISTORY,
      reports: STORAGE_KEYS.DEEP_RESEARCH_REPORTS,
      streamData: STORAGE_KEYS.DEEP_RESEARCH_STREAM_DATA,
      requestState: STORAGE_KEYS.DEEP_RESEARCH_REQUEST_STATE,
    },
    translations: {
      id: {
        placeholder: translations.id.deepResearchChat.placeholder,
        send: translations.id.deepResearchChat.send,
        processing: translations.id.deepResearchChat.processing,
        error: translations.id.deepResearchChat.error,
        errorMessage: translations.id.deepResearchChat.errorMessage,
        focus: {
          selectFirst: translations.id.deepResearchChat.focus.selectFirst,
        },
        status: {
          starting: translations.id.deepResearchChat.status.starting,
          complete: translations.id.deepResearchChat.status.complete,
          restoring: translations.id.deepResearchChat.status.restoring,
          noData: translations.id.deepResearchChat.status.noData,
          noFinalReport: translations.id.deepResearchChat.status.noFinalReport,
          incomplete: translations.id.deepResearchChat.status.incomplete,
        },
        report: {
          open: translations.id.deepResearchChat.report.open,
          sources: translations.id.deepResearchChat.report.sources,
          characters: translations.id.deepResearchChat.report.characters,
        },
      },
      en: {
        placeholder: translations.en.deepResearchChat.placeholder,
        send: translations.en.deepResearchChat.send,
        processing: translations.en.deepResearchChat.processing,
        error: translations.en.deepResearchChat.error,
        errorMessage: translations.en.deepResearchChat.errorMessage,
        focus: {
          selectFirst: translations.en.deepResearchChat.focus.selectFirst,
        },
        status: {
          starting: translations.en.deepResearchChat.status.starting,
          complete: translations.en.deepResearchChat.status.complete,
          restoring: translations.en.deepResearchChat.status.restoring,
          noData: translations.en.deepResearchChat.status.noData,
          noFinalReport: translations.en.deepResearchChat.status.noFinalReport,
          incomplete: translations.en.deepResearchChat.status.incomplete,
        },
        report: {
          open: translations.en.deepResearchChat.report.open,
          sources: translations.en.deepResearchChat.report.sources,
          characters: translations.en.deepResearchChat.report.characters,
        },
      },
    },
  }}
>
  const t = translations[locale];
  const form = document.getElementById('deep-research-form');
  const input = document.getElementById('deep-research-input');
  const submitBtn = document.getElementById('deep-research-submit');
  const messagesContainer = document.getElementById('deep-research-messages');

  if (!form || !input || !submitBtn || !messagesContainer) {
    // Elements not found, will retry
  } else {
    // Storage keys from config
    const STORAGE_KEY = storageKeys.chatHistory;
    const STORAGE_REPORTS_KEY = storageKeys.reports;
    const STORAGE_STREAM_KEY = storageKeys.streamData;
    const STORAGE_REQUEST_STATE_KEY = storageKeys.requestState;

    // Check if this is a full page refresh (not navigation)
    const checkNavigationType = () => {
      try {
        const navEntries = performance.getEntriesByType('navigation');
        if (navEntries && navEntries.length > 0) {
          const navEntry = navEntries[0];
          return navEntry.type; // 'reload', 'navigate', 'back_forward', etc.
        }
      } catch (error) {
        // Fallback
      }
      return 'navigate'; // Default to navigate
    };
    // Render markdown
    const renderMarkdown = (text) => {
      try {
        // @ts-ignore
        if (typeof window !== 'undefined' && window.marked) {
          // @ts-ignore
          return window.marked.parse(text);
        }
        return text;
      } catch (error) {
        return text;
      }
    };

    // Save chat history to localStorage
    const saveChatHistory = (text, isUser) => {
      try {
        const existingHistory = localStorage.getItem(STORAGE_KEY);
        const messages = existingHistory ? JSON.parse(existingHistory) : [];

        messages.push({
          text,
          isUser,
          timestamp: Date.now(),
        });

        // Keep only last 100 messages to avoid storage limit
        const trimmedMessages = messages.slice(-100);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmedMessages));
      } catch (error) {
        console.error('Error saving chat history:', error);
      }
    };

    // Save report to localStorage
    const saveReport = (title, report, sources) => {
      try {
        const existingReports = localStorage.getItem(STORAGE_REPORTS_KEY);
        const reports = existingReports ? JSON.parse(existingReports) : [];

        reports.push({
          title,
          report,
          sources: sources || [],
          timestamp: Date.now(),
        });

        // Keep only last 20 reports
        const trimmedReports = reports.slice(-20);
        localStorage.setItem(STORAGE_REPORTS_KEY, JSON.stringify(trimmedReports));
      } catch (error) {
        console.error('Error saving report:', error);
      }
    };

    // Save streaming chunk to localStorage
    const saveStreamChunk = (chunkData) => {
      try {
        const existingStream = localStorage.getItem(STORAGE_STREAM_KEY);
        const streamData = existingStream
          ? JSON.parse(existingStream)
          : {
              chunks: [],
              lastUpdate: Date.now(),
            };

        streamData.chunks.push({
          ...chunkData,
          timestamp: Date.now(),
        });
        streamData.lastUpdate = Date.now();

        // Keep only last 1000 chunks to avoid storage limit
        if (streamData.chunks.length > 1000) {
          streamData.chunks = streamData.chunks.slice(-1000);
        }

        localStorage.setItem(STORAGE_STREAM_KEY, JSON.stringify(streamData));
      } catch (error) {
        console.error('Error saving stream chunk:', error);
      }
    };

    // Save request state
    const saveRequestState = (state) => {
      try {
        localStorage.setItem(
          STORAGE_REQUEST_STATE_KEY,
          JSON.stringify({
            ...state,
            lastUpdate: Date.now(),
          })
        );
      } catch (error) {
        console.error('Error saving request state:', error);
      }
    };

    // Clear request state
    const clearRequestState = () => {
      try {
        localStorage.removeItem(STORAGE_REQUEST_STATE_KEY);
        localStorage.removeItem(STORAGE_STREAM_KEY);
      } catch (error) {
        console.error('Error clearing request state:', error);
      }
    };

    // Load chat history from localStorage
    const loadChatHistory = () => {
      try {
        const savedHistory = localStorage.getItem(STORAGE_KEY);
        const savedReports = localStorage.getItem(STORAGE_REPORTS_KEY);

        if (savedHistory) {
          const messages = JSON.parse(savedHistory);

          // Clear welcome message if we have saved messages
          if (messages.length > 0) {
            const welcomeMessage = messagesContainer.querySelector('.flex.items-start.space-x-2');
            if (welcomeMessage && welcomeMessage.textContent?.includes(t.welcome)) {
              welcomeMessage.remove();
            }

            // Restore messages
            messages.forEach((msg) => {
              addMessage(msg.text, msg.isUser, false); // false = don't save to storage again
            });
          }
        }

        // Restore report cards
        if (savedReports) {
          const reports = JSON.parse(savedReports);
          reports.forEach((reportData) => {
            addReportCard(reportData.title, reportData.report, reportData.sources, false);
          });
        }
      } catch (error) {
        console.error('Error loading chat history:', error);
      }
    };

    // Add message to DOM
    const addMessage = (text, isUser = false, saveToStorage = true) => {
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex items-start space-x-2 sm:space-x-3 ${isUser ? 'flex-row-reverse space-x-reverse' : ''}`;

      if (!isUser) {
        const avatar = document.createElement('div');
        avatar.className =
          'flex h-7 w-7 sm:h-8 sm:w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900';
        avatar.innerHTML = `
          <svg class="h-4 w-4 sm:h-5 sm:w-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        `;
        messageDiv.appendChild(avatar);
      }

      const contentDiv = document.createElement('div');
      contentDiv.className = `flex-1 rounded-lg px-3 py-2 sm:px-4 sm:py-3 ${
        isUser
          ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white'
          : 'bg-gray-100 dark:bg-gray-700'
      }`;

      if (!isUser) {
        const markdownContent = document.createElement('div');
        markdownContent.className =
          'prose prose-sm prose-slate max-w-none dark:prose-invert text-xs sm:text-sm';
        markdownContent.innerHTML = renderMarkdown(text);
        contentDiv.appendChild(markdownContent);
      } else {
        const textP = document.createElement('p');
        textP.className = 'text-xs sm:text-sm text-white break-words';
        textP.textContent = text;
        contentDiv.appendChild(textP);
      }

      messageDiv.appendChild(contentDiv);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;

      // Save to localStorage if not loading from storage
      if (saveToStorage) {
        saveChatHistory(text, isUser);
      }
    };

    // Add report card to reopen the report
    const addReportCard = (title, report, sourcesList = [], saveToStorage = true) => {
      const cardId = `report-card-${Date.now()}`;
      const cardDate = new Date().toLocaleDateString(locale === 'id' ? 'id-ID' : 'en-US', {
        day: 'numeric',
        month: 'short',
        hour: '2-digit',
        minute: '2-digit',
      });
      const t = translations[locale];
      const buttonText = t.report.open;

      const researchCard = document.createElement('div');
      researchCard.className = 'flex items-start space-x-2 sm:space-x-3';
      researchCard.innerHTML = `
          <div class="flex h-7 w-7 sm:h-8 sm:w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900">
            <svg class="h-4 w-4 sm:h-5 sm:w-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
            </svg>
          </div>
          <div class="flex-1 min-w-0">
          <div class="group relative flex flex-col sm:flex-row sm:items-center gap-3 sm:gap-4 rounded-xl border border-gray-200 bg-white p-3 sm:p-4 transition-all hover:border-gray-300 hover:shadow-md dark:border-gray-700 dark:bg-gray-800 dark:hover:border-gray-600 cursor-pointer" id="${cardId}">
              <div class="flex h-10 w-10 sm:h-12 sm:w-12 shrink-0 items-center justify-center rounded-lg bg-gradient-to-br from-blue-500 via-purple-500 to-pink-500">
                <svg class="h-5 w-5 sm:h-6 sm:w-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                </svg>
              </div>
              <div class="flex-1 min-w-0">
              <h3 class="truncate text-sm sm:text-base font-medium text-gray-900 dark:text-gray-100">${title}</h3>
              <p class="mt-1 text-xs sm:text-sm text-gray-500 dark:text-gray-400">${cardDate}${sourcesList.length > 0 ? ` ‚Ä¢ ${sourcesList.length} ${t.report.sources}` : ''}</p>
              </div>
            <button class="report-open-btn w-full sm:w-auto flex items-center justify-center gap-2 rounded-lg bg-blue-600 px-4 py-2.5 sm:py-2 text-sm font-medium text-white transition-colors hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 touch-manipulation">
                ${buttonText}
              </button>
            </div>
          </div>
        `;

      messagesContainer.appendChild(researchCard);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;

      // Add click handlers
      const card = document.getElementById(cardId);
      const openBtn = card?.querySelector('.report-open-btn');

      if (card && openBtn) {
        const openReport = (e) => {
          e.stopPropagation();
          e.preventDefault();

          // @ts-ignore
          if (typeof window !== 'undefined' && window.displayDeepResearchReport) {
            // @ts-ignore
            window.displayDeepResearchReport(report, title);
          } else {
            // Fallback: show as message
            addMessage(report, false);
          }
          return false;
        };

        openBtn.addEventListener('click', openReport);
        card.addEventListener('click', (e) => {
          if (e.target !== openBtn && !openBtn.contains(e.target)) {
            openReport(e);
          }
        });
      }

      // Save report to localStorage
      if (saveToStorage) {
        saveReport(title, report, sourcesList);
      }
    };

    // Restore streaming progress if request was interrupted
    const restoreStreamProgress = () => {
      try {
        const savedState = localStorage.getItem(STORAGE_REQUEST_STATE_KEY);
        const savedStream = localStorage.getItem(STORAGE_STREAM_KEY);

        if (savedState && savedStream) {
          const state = JSON.parse(savedState);
          const streamData = JSON.parse(savedStream);

          // Only restore if request was still processing (not completed/error)
          if (state.status === 'processing' || state.status === 'completed') {
            // Show that we're restoring progress
            const t = translations[locale];
            const restoreMessage = `üîÑ ${t.status.restoring}`;
            let restoredStatusMessageId = addStatusMessage(restoreMessage, null, false);

            // Restore all chunks
            let restoredFinalReport = null;
            let restoredSources = [];

            streamData.chunks.forEach((chunk) => {
              const data = chunk;

              if (data.type === 'status') {
                const statusText = data.message || t.processing;
                const msgId = addStatusMessage(statusText, null, false);
                if (!restoredStatusMessageId) {
                  restoredStatusMessageId = msgId;
                }
              } else if (data.type === 'thought') {
                if (data.content) {
                  addStatusMessage(data.content, null, false);
                }
              } else if (data.type === 'final') {
                // If we have final report, restore it
                if (data.report) {
                  restoredFinalReport = data.report;
                  restoredSources = data.sources || [];

                  const t = translations[locale];
                  const completeMessage = `‚úÖ ${t.status.complete} ${t.report.characters}: ${data.report_length || 0}`;
                  addStatusMessage(completeMessage, null, false);

                  // Restore report card
                  setTimeout(() => {
                    addReportCard(state.topic, restoredFinalReport, restoredSources, false);
                  }, 100);

                  // Clear request state
                  clearRequestState();
                }
              }
            });

            // If we have a final report, display it
            if (
              restoredFinalReport &&
              typeof window !== 'undefined' &&
              window.displayDeepResearchReport
            ) {
              setTimeout(() => {
                window.displayDeepResearchReport(restoredFinalReport, state.topic);
              }, 200);
            }
          }
        }
      } catch (error) {
        console.error('Error restoring stream progress:', error);
      }
    };

    // Handle page visibility changes to ensure data is saved
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Page is hidden, ensure all data is saved
        // This is already handled by saveStreamChunk and saveRequestState
      } else {
        // Page is visible again, check if we need to restore progress
        restoreStreamProgress();
      }
    });

    // Handle beforeunload to ensure data is saved
    window.addEventListener('beforeunload', () => {
      // Force save any pending data
      // This is already handled by saveStreamChunk and saveRequestState
    });

    // Check navigation type and load/clear history
    const navType = checkNavigationType();
    if (navType === 'reload') {
      // Full page refresh (hard refresh) - clear history
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(STORAGE_REPORTS_KEY);
      localStorage.removeItem(STORAGE_STREAM_KEY);
      localStorage.removeItem(STORAGE_REQUEST_STATE_KEY);
    } else {
      // Navigation (not refresh) - load history and restore progress
      loadChatHistory();
      restoreStreamProgress();
    }

    // Auto-resize textarea
    const autoResize = () => {
      input.style.height = 'auto';
      // Smaller max height on mobile
      const maxHeight = window.innerWidth < 640 ? 100 : 120;
      input.style.height = Math.min(input.scrollHeight, maxHeight) + 'px';
    };

    input.addEventListener('input', autoResize);

    // Handle Enter key (Shift+Enter for new line, Enter to submit)
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        form.dispatchEvent(new Event('submit'));
      }
    });

    // Update status message
    const updateStatusMessage = (messageId, text) => {
      const messageEl = document.getElementById(messageId);
      if (messageEl) {
        const contentEl = messageEl.querySelector('.status-content');
        if (contentEl) {
          contentEl.textContent = text;
          // Update icon based on content
          const iconContainer = messageEl.querySelector('div > div');
          if (iconContainer && text) {
            let iconSvg = '';
            if (text.includes('üîç') || text.includes('Searching')) {
              iconSvg = `
                <svg class="h-4 w-4 sm:h-5 sm:w-5 text-blue-600 dark:text-blue-400 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
              `;
            } else if (
              text.includes('‚úì') ||
              text.includes('Found') ||
              text.includes('‚úÖ') ||
              text.includes('complete')
            ) {
              iconSvg = `
                <svg class="h-4 w-4 sm:h-5 sm:w-5 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              `;
            } else if (text.includes('‚è≥') || text.includes('Retrieving')) {
              iconSvg = `
                <svg class="h-4 w-4 sm:h-5 sm:w-5 text-yellow-600 dark:text-yellow-400 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
              `;
            }
            if (iconSvg) {
              iconContainer.innerHTML = iconSvg;
            }
          }
        }
      }
    };

    // Add status/thought message
    const addStatusMessage = (text, messageId = null, saveToStorage = true) => {
      const messageDiv = document.createElement('div');
      const id = messageId || `status-${Date.now()}`;
      messageDiv.id = id;
      messageDiv.className = 'flex items-start space-x-2 sm:space-x-3';

      // Different icon based on content
      let iconSvg = '';
      if (text.includes('üîç') || text.includes('Searching')) {
        iconSvg = `
          <svg class="h-4 w-4 sm:h-5 sm:w-5 text-blue-600 dark:text-blue-400 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        `;
      } else if (text.includes('‚úì') || text.includes('Found')) {
        iconSvg = `
          <svg class="h-4 w-4 sm:h-5 sm:w-5 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        `;
      } else if (text.includes('‚è≥') || text.includes('Retrieving')) {
        iconSvg = `
          <svg class="h-4 w-4 sm:h-5 sm:w-5 text-yellow-600 dark:text-yellow-400 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
        `;
      } else if (text.includes('‚úÖ') || text.includes('complete')) {
        iconSvg = `
          <svg class="h-4 w-4 sm:h-5 sm:w-5 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        `;
      } else {
        iconSvg = `
          <svg class="h-4 w-4 sm:h-5 sm:w-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        `;
      }

      messageDiv.innerHTML = `
        <div class="flex h-7 w-7 sm:h-8 sm:w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900">
          ${iconSvg}
        </div>
        <div class="flex-1 rounded-lg bg-gray-100 px-3 py-2 sm:px-4 sm:py-3 dark:bg-gray-700">
          <p class="status-content text-xs sm:text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap break-words">${text}</p>
        </div>
      `;
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;

      // Save status message to localStorage
      if (saveToStorage) {
        saveChatHistory(text, false);
      }

      return id;
    };

    // Handle form submission
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const topic = input.value.trim();
      if (!topic) return;

      addMessage(topic, true);
      input.value = '';
      input.style.height = 'auto';
      submitBtn.disabled = true;
      submitBtn.innerHTML = `
        <svg class="h-5 w-5 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
        </svg>
      `;

      // Determine language and focus
      const language = locale === 'id' ? 'Indonesia' : 'English';
      const focusSelect = document.getElementById('deep-research-focus');
      const selectedFocus = focusSelect?.value;

      if (!selectedFocus) {
        addMessage(`${t.error}: ${t.focus.selectFirst}`, false);
        submitBtn.disabled = false;
        submitBtn.innerHTML = `
          <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
          </svg>
        `;
        return;
      }

      const focus = selectedFocus;

      let statusMessageId = null;
      let finalReport = null;
      let sources = [];

      // Show initial processing message immediately
      const t = translations[locale];
      const initialMessage = `üîÑ ${t.status.starting} "${topic}"...`;

      // Ensure messagesContainer exists
      if (!messagesContainer) {
        console.error('messagesContainer not found!');
        return;
      }

      // Save request state
      saveRequestState({
        topic,
        focus,
        language,
        status: 'processing',
        startTime: Date.now(),
      });

      statusMessageId = addStatusMessage(initialMessage, null, true);

      try {
        // Get utility functions from window
        // @ts-ignore
        const { createDeepResearchRequest, processStreamingResponse } =
          window.deepResearchUtils || {};

        if (!createDeepResearchRequest || !processStreamingResponse) {
          throw new Error('Deep research utilities not loaded. Please refresh the page.');
        }

        // Create request and get response
        const response = await createDeepResearchRequest(apiEndpoint, {
          topic,
          focus,
          language,
        });

        // Process streaming response
        await processStreamingResponse(response, (chunk) => {
          // Save chunk to localStorage immediately
          saveStreamChunk(chunk);

          // Handle status messages
          if (chunk.type === 'status') {
            const statusText = chunk.message || t.processing;

            // Update request state
            saveRequestState({
              topic,
              focus,
              language,
              status: 'processing',
              lastStatus: statusText,
              startTime: Date.now(),
            });

            if (!statusMessageId) {
              statusMessageId = addStatusMessage(statusText, null, true);
            } else {
              updateStatusMessage(statusMessageId, statusText);
            }
          }
          // Handle thought messages (searching, found results, etc.)
          else if (chunk.type === 'thought') {
            if (chunk.content) {
              // Always add new thought messages (don't update existing ones)
              addStatusMessage(chunk.content);
            }
          }
          // Handle final report
          else if (chunk.type === 'final') {
            // Store final report
            finalReport = chunk.report || '';
            sources = chunk.sources || [];

            // Update request state to completed
            saveRequestState({
              topic,
              focus,
              language,
              status: 'completed',
              reportLength: chunk.report_length,
              complete: chunk.complete,
            });

            // Show completion message
            const t = translations[locale];
            const incompleteNote = chunk.complete === false ? ` [${t.status.incomplete}]` : '';
            const completeMessage = `‚úÖ ${t.status.complete} ${t.report.characters}: ${chunk.report_length || 0}${incompleteNote}`;

            addStatusMessage(completeMessage);

            // Show sources if available
            if (sources && sources.length > 0) {
              const t = translations[locale];
              const sourcesText = `üìö ${t.report.sources} (${sources.length}):\n${sources.map((s, i) => `${i + 1}. ${s.title || s.url || s.domain || 'Unknown'}`).join('\n')}`;
              addStatusMessage(sourcesText);
            }

            // Display the report and create a card to reopen it
            if (finalReport) {
              const reportTitle = topic;

              // Store report globally so it can be reopened
              // @ts-ignore
              if (typeof window !== 'undefined') {
                // @ts-ignore
                window.lastDeepResearchReport = {
                  report: finalReport,
                  title: reportTitle,
                  sources: sources,
                  timestamp: new Date().toISOString(),
                };
              }

              // Display the report
              // @ts-ignore
              if (typeof window !== 'undefined' && window.displayDeepResearchReport) {
                // @ts-ignore
                window.displayDeepResearchReport(finalReport, reportTitle);
              } else {
                // Fallback: show report as message
                addMessage(finalReport, false);
              }

              // Save report to localStorage
              saveReport(reportTitle, finalReport, sources);

              // Clear request state and stream data after completion
              clearRequestState();

              // Add a card to reopen the report
              setTimeout(() => {
                addReportCard(reportTitle, finalReport, sources, true);
              }, 500);
            }
          }
        });

        // If we got data but no final report, show warning
        if (!finalReport) {
          const t = translations[locale];
          const warningMsg = `‚ö†Ô∏è ${t.status.noFinalReport}`;
          addStatusMessage(warningMsg);
        }

        // If we have a final report but didn't display it yet (fallback)
        if (finalReport) {
          // Try to display report one more time if it wasn't displayed
          setTimeout(() => {
            // @ts-ignore
            if (
              typeof window !== 'undefined' &&
              window.displayDeepResearchReport &&
              !document.getElementById('deep-research-report-canvas')?.classList.contains('active')
            ) {
              // @ts-ignore
              window.displayDeepResearchReport(finalReport, topic);
            }
          }, 100);
        }
      } catch (error) {
        console.error('Error in form submission:', error);
        const errorMessage = error instanceof Error ? error.message : t.errorMessage;

        // Update request state to error
        saveRequestState({
          topic,
          focus,
          language,
          status: 'error',
          error: errorMessage,
        });

        // Remove loading/status message if exists
        if (statusMessageId) {
          const statusEl = document.getElementById(statusMessageId);
          if (statusEl) {
            statusEl.remove();
          }
        }

        addMessage(`${t.error}: ${errorMessage}`, false);
      } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = `
          <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
          </svg>
        `;
        input.focus();
      }
    });
  }
</script>

<style>
  #deep-research-messages {
    scrollbar-width: thin;
    scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
  }

  #deep-research-messages::-webkit-scrollbar {
    width: 6px;
  }

  #deep-research-messages::-webkit-scrollbar-track {
    background: transparent;
  }

  #deep-research-messages::-webkit-scrollbar-thumb {
    background-color: rgba(156, 163, 175, 0.5);
    border-radius: 3px;
  }

  #deep-research-messages::-webkit-scrollbar-thumb:hover {
    background-color: rgba(156, 163, 175, 0.7);
  }

  /* Mobile optimizations */
  @media (max-width: 640px) {
    #deep-research-chat {
      border-radius: 0.5rem;
    }

    /* Ensure touch targets are at least 44x44px */
    #deep-research-submit {
      min-width: 44px;
      min-height: 44px;
    }

    /* Better text wrapping on mobile */
    #deep-research-messages .prose {
      word-break: break-word;
      overflow-wrap: break-word;
    }

    /* Prevent horizontal overflow */
    #deep-research-messages {
      overflow-x: hidden;
    }
  }
</style>
