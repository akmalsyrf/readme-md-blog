---
import ChatButton from './ChatButton.astro';
import ChatWindow from './ChatWindow.astro';
import { getTranslations, type Locale } from '../../utils/i18n';

interface Props {
  locale?: Locale;
}

const { locale = 'id' } = Astro.props;
const t = getTranslations(locale);
---

<div id="chatbot-container" class="chatbot-container">
  <ChatButton locale={locale} />
  <ChatWindow locale={locale} />
</div>

<!-- Load marked library -->
<script type="module">
  import { marked } from 'https://cdn.jsdelivr.net/npm/marked@17.0.1/+esm';

  // Configure marked
  marked.setOptions({
    breaks: true,
    gfm: true,
  });

  // Make marked available globally
  // @ts-ignore
  window.marked = marked;
</script>

<script
  define:vars={{
    locale,
    translations: {
      id: {
        welcome: t.chatbot.welcome,
        placeholder: t.chatbot.placeholder,
        send: t.chatbot.send,
        processing: t.chatbot.processing,
        sources: t.chatbot.sources,
        error: t.chatbot.error,
        errorMessage: t.chatbot.errorMessage,
        generatingRecommendations: t.chatbot.generatingRecommendations,
        recommendations: t.chatbot.recommendations,
      },
      en: {
        welcome:
          'Hello! I can help answer questions about the notes in Readme.md. Please ask me something!',
        placeholder: 'Type your question...',
        send: 'Send',
        processing: 'Processing...',
        sources: 'Sources',
        error: 'An error occurred',
        errorMessage: 'An error occurred while sending the message. Please try again.',
        generatingRecommendations: 'Generating question recommendations...',
        recommendations: 'Questions you might ask:',
      },
    },
  }}
>
  const t = translations[locale];

  // Get DOM elements
  const container = document.getElementById('chatbot-container');
  const toggle = document.getElementById('chatbot-toggle');
  const closeBtn = document.getElementById('chatbot-close');
  const window = document.getElementById('chatbot-window');
  const icon = document.getElementById('chatbot-icon');
  const form = document.getElementById('chatbot-form');
  const input = document.getElementById('chatbot-input');
  const submitBtn = document.getElementById('chatbot-submit');
  const messagesContainer = document.getElementById('chatbot-messages');
  const recommendationsContainer = document.getElementById('chatbot-recommendations');

  if (
    !container ||
    !toggle ||
    !closeBtn ||
    !window ||
    !icon ||
    !form ||
    !input ||
    !submitBtn ||
    !messagesContainer ||
    !recommendationsContainer
  ) {
    // eslint-disable-next-line no-console
    console.error('ChatBot: Required DOM elements not found');
  } else {
    // Storage keys
    const STORAGE_KEY = 'chatbot_history';
    const STORAGE_STATE_KEY = 'chatbot_state';

    // Check if this is a full page refresh (not navigation)
    const checkNavigationType = () => {
      try {
        const navEntries = performance.getEntriesByType('navigation');
        if (navEntries && navEntries.length > 0) {
          const navEntry = navEntries[0];
          return navEntry.type; // 'reload', 'navigate', 'back_forward', etc.
        }
      } catch (error) {
        // Fallback
      }
      return 'navigate'; // Default to navigate
    };

    // Helper function to render markdown (needed by addMessageToDOM)
    const renderMarkdown = (text) => {
      try {
        // Use marked from window if available
        // @ts-ignore
        if (typeof window !== 'undefined' && window.marked) {
          // @ts-ignore
          return window.marked.parse(text);
        }

        // Enhanced fallback: better markdown parsing
        let html = text;

        // Split into lines for better processing
        const lines = html.split('\n');
        const processedLines = [];
        let inList = false;
        let listType = null; // 'ol' or 'ul'
        let listItems = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();

          // Check for numbered list: "1. text"
          const numberedMatch = line.match(/^(\d+)\.\s+(.+)$/);
          if (numberedMatch) {
            if (!inList || listType !== 'ol') {
              if (inList && listItems.length > 0) {
                processedLines.push(`<${listType}>${listItems.join('')}</${listType}>`);
                listItems = [];
              }
              inList = true;
              listType = 'ol';
            }
            listItems.push(`<li>${numberedMatch[2]}</li>`);
            continue;
          }

          // Check for bullet list: "- text" or "* text"
          const bulletMatch = line.match(/^[-*]\s+(.+)$/);
          if (bulletMatch) {
            if (!inList || listType !== 'ul') {
              if (inList && listItems.length > 0) {
                processedLines.push(`<${listType}>${listItems.join('')}</${listType}>`);
                listItems = [];
              }
              inList = true;
              listType = 'ul';
            }
            listItems.push(`<li>${bulletMatch[1]}</li>`);
            continue;
          }

          // Not a list item - close list if open
          if (inList) {
            processedLines.push(`<${listType}>${listItems.join('')}</${listType}>`);
            listItems = [];
            inList = false;
            listType = null;
          }

          // Regular line
          if (line) {
            processedLines.push(line);
          } else {
            processedLines.push('');
          }
        }

        // Close any open list
        if (inList && listItems.length > 0) {
          processedLines.push(`<${listType}>${listItems.join('')}</${listType}>`);
        }

        html = processedLines.join('\n');

        // Bold: **text**
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

        // Italic: *text* (but not **text**)
        html = html.replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, '<em>$1</em>');

        // Inline code: `code`
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

        // Paragraphs: split by double newlines
        const paragraphs = html.split(/\n\n+/);
        html = paragraphs
          .map((p) => {
            p = p.trim();
            if (!p) return '';
            if (!p.startsWith('<')) {
              return '<p>' + p + '</p>';
            }
            return p;
          })
          .join('\n');

        // Single line breaks
        html = html.replace(/\n/g, '<br>');

        return html;
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error parsing markdown:', error);
        return text; // Fallback to plain text
      }
    };

    // Add message to DOM (internal function, can skip saving)
    const addMessageToDOM = (text, isUser = false, sources, saveToStorage = true) => {
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex items-start space-x-2 mb-6 ${isUser ? 'flex-row-reverse space-x-reverse' : ''}`;

      if (!isUser) {
        const avatar = document.createElement('div');
        avatar.className =
          'flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900';
        avatar.innerHTML = `
          <svg class="h-5 w-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        `;
        messageDiv.appendChild(avatar);
      }

      const contentDiv = document.createElement('div');
      contentDiv.className = `flex-1 rounded-lg px-4 py-3 ${
        isUser ? 'bg-blue-600 text-white' : 'bg-gray-100 dark:bg-gray-700'
      }`;

      // Render markdown for bot messages, plain text for user messages
      if (!isUser) {
        // Render markdown to HTML for bot responses
        // Use Tailwind Typography (same as BlogPostContent) but smaller size
        const markdownContent = document.createElement('div');
        markdownContent.className = 'prose prose-sm prose-slate max-w-none dark:prose-invert';

        // Parse markdown synchronously
        const html = renderMarkdown(text);
        markdownContent.innerHTML = html;
        contentDiv.appendChild(markdownContent);
      } else {
        // User messages remain as plain text
        const textP = document.createElement('p');
        textP.className = 'text-sm text-white';
        textP.textContent = text;
        contentDiv.appendChild(textP);
      }

      // Add sources if available
      if (sources && sources.length > 0) {
        const sourcesDiv = document.createElement('div');
        sourcesDiv.className = 'mt-3 border-t border-gray-300 pt-3 dark:border-gray-600';

        const sourcesTitle = document.createElement('p');
        sourcesTitle.className = 'mb-2 text-xs font-semibold text-gray-600 dark:text-gray-400';
        sourcesTitle.textContent = t.sources + ':';
        sourcesDiv.appendChild(sourcesTitle);

        const sourcesList = document.createElement('ul');
        sourcesList.className = 'space-y-1';
        sources.forEach((source) => {
          const sourceItem = document.createElement('li');
          sourceItem.className = 'text-xs text-gray-600 dark:text-gray-400';
          const link = document.createElement('a');
          link.href = `/${locale}/notes/${source.noteId}`;
          link.className = 'hover:text-blue-600 dark:hover:text-blue-400 underline';
          link.textContent = source.title;
          sourceItem.appendChild(link);
          sourcesList.appendChild(sourceItem);
        });
        sourcesDiv.appendChild(sourcesList);
        contentDiv.appendChild(sourcesDiv);
      }

      messageDiv.appendChild(contentDiv);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;

      // Hide recommendations after first message
      if (!hasMessages) {
        hasMessages = true;
        recommendationsContainer.innerHTML = '';
      }

      // Save to localStorage if requested
      if (saveToStorage) {
        saveChatHistory(text, isUser, sources);
        saveChatState();
      }
    };

    // Load chat history from localStorage
    const loadChatHistory = () => {
      try {
        const savedHistory = localStorage.getItem(STORAGE_KEY);
        const savedState = localStorage.getItem(STORAGE_STATE_KEY);

        if (savedHistory) {
          const messages = JSON.parse(savedHistory);

          // Clear welcome message if we have saved messages
          if (messages.length > 0) {
            const welcomeMessage = messagesContainer.querySelector('.chatbot-message-bot');
            if (welcomeMessage) {
              welcomeMessage.remove();
            }

            // Restore messages
            messages.forEach((msg) => {
              addMessageToDOM(msg.text, msg.isUser, msg.sources, false); // false = don't save to storage
            });

            hasMessages = true;
            recommendationsContainer.innerHTML = '';
          }
        }

        // Restore chat window state
        if (savedState) {
          const state = JSON.parse(savedState);
          if (state.isOpen) {
            isOpen = true;
            window.classList.remove('hidden');
            window.style.display = 'flex';
            icon.classList.add('rotated');
          }
        }
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error loading chat history:', error);
      }
    };

    // Save chat history to localStorage
    const saveChatHistory = (text, isUser, sources) => {
      try {
        const existingHistory = localStorage.getItem(STORAGE_KEY);
        const messages = existingHistory ? JSON.parse(existingHistory) : [];

        messages.push({
          text,
          isUser,
          sources: sources || [],
          timestamp: Date.now(),
        });

        // Keep only last 50 messages to avoid storage limit
        const trimmedMessages = messages.slice(-50);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmedMessages));
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error saving chat history:', error);
      }
    };

    // Save chat state (isOpen)
    const saveChatState = () => {
      try {
        localStorage.setItem(
          STORAGE_STATE_KEY,
          JSON.stringify({
            isOpen,
            hasMessages,
          })
        );
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error saving chat state:', error);
      }
    };

    let isOpen = false;
    let hasMessages = false;

    // Check navigation type and clear history only on full page refresh
    const navType = checkNavigationType();
    if (navType === 'reload') {
      // Full page refresh - clear history
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(STORAGE_STATE_KEY);
    } else {
      // Navigation (not refresh) - load history
      loadChatHistory();
    }

    // Auto-resize textarea
    const autoResize = () => {
      input.style.height = 'auto';
      const maxHeight = 120; // ~3 rows
      input.style.height = Math.min(input.scrollHeight, maxHeight) + 'px';
    };

    // Load recommendations
    const loadRecommendations = async () => {
      if (hasMessages) return; // Don't load if already has conversation

      // Show loading state
      recommendationsContainer.innerHTML = `
        <div class="flex items-center space-x-2 text-sm text-gray-600 dark:text-gray-400">
          <svg class="h-4 w-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
          <span>${t.generatingRecommendations}</span>
        </div>
      `;

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            action: 'getRecommendations',
            locale,
          }),
        });

        if (response.ok) {
          const data = await response.json();
          if (data.recommendations && data.recommendations.length > 0) {
            displayRecommendations(data.recommendations);
          } else {
            recommendationsContainer.innerHTML = '';
          }
        } else {
          recommendationsContainer.innerHTML = '';
        }
      } catch (error) {
        // Silently fail - recommendations are optional
        recommendationsContainer.innerHTML = '';
      }
    };

    // Display recommendations
    const displayRecommendations = (recommendations) => {
      recommendationsContainer.innerHTML = `
        <div class="mb-2 text-xs font-semibold text-gray-600 dark:text-gray-400">
          ${t.recommendations}
        </div>
      `;

      recommendations.forEach((rec) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className =
          'w-full mb-2 text-left rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm text-gray-700 transition-colors hover:border-blue-500 hover:bg-blue-50 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-300 dark:hover:border-blue-500 dark:hover:bg-blue-900/20';
        button.textContent = rec;
        button.addEventListener('click', () => {
          input.value = rec;
          autoResize();
          form.dispatchEvent(new Event('submit'));
        });
        recommendationsContainer.appendChild(button);
      });
    };

    // Toggle chat window
    const toggleChat = () => {
      isOpen = !isOpen;
      if (isOpen) {
        window.classList.remove('hidden');
        window.style.display = 'flex';
        icon.classList.add('rotated');
        input.focus();
        autoResize();
        if (!hasMessages) {
          loadRecommendations();
        }
      } else {
        window.classList.add('hidden');
        window.style.display = 'none';
        icon.classList.remove('rotated');
      }
      saveChatState();
    };

    // Auto-resize on input
    input.addEventListener('input', autoResize);

    // Handle Enter key (Shift+Enter for new line, Enter to submit)
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        form.dispatchEvent(new Event('submit'));
      }
    });

    toggle.addEventListener('click', toggleChat);
    closeBtn.addEventListener('click', toggleChat);

    // Add message to chat (public function)
    const addMessage = (text, isUser = false, sources) => {
      addMessageToDOM(text, isUser, sources, true);
    };

    // Add loading indicator
    const addLoading = () => {
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'chatbot-loading';
      loadingDiv.className = 'flex items-start space-x-2 mb-6';
      loadingDiv.innerHTML = `
        <div class="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900">
          <svg class="h-5 w-5 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        </div>
        <div class="flex-1 rounded-lg bg-gray-100 px-4 py-3 dark:bg-gray-700">
          <p class="text-sm text-gray-700 dark:text-gray-300">${t.processing}</p>
        </div>
      `;
      messagesContainer.appendChild(loadingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    };

    // Remove loading indicator
    const removeLoading = () => {
      const loading = document.getElementById('chatbot-loading');
      if (loading) {
        loading.remove();
      }
    };

    // Handle form submission
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const question = input.value.trim();
      if (!question) return;

      // Add user message
      addMessage(question, true);
      input.value = '';
      input.style.height = 'auto';
      submitBtn.disabled = true;
      submitBtn.textContent = t.processing;

      // Add loading indicator
      addLoading();

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            question,
            locale,
          }),
        });

        removeLoading();

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
          throw new Error(errorData.message || errorData.error || t.errorMessage);
        }

        const data = await response.json();

        if (data.error) {
          addMessage(`${t.error}: ${data.message || data.error}`, false);
        } else {
          addMessage(data.answer || '', false, data.sources);
        }
      } catch (error) {
        removeLoading();
        const errorMessage = error instanceof Error ? error.message : t.errorMessage;
        addMessage(`${t.error}: ${errorMessage}`, false);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = t.send;
        input.focus();
      }
    });
  }
</script>

<style>
  .chatbot-container {
    @apply fixed bottom-6 right-6 z-50;
  }

  /* Mobile responsive styles */
  @media (max-width: 640px) {
    .chatbot-container {
      @apply bottom-4 right-4;
    }
  }

  /* Override prose spacing for chat context - make it more compact */
  .chatbot-messages .prose {
    @apply text-sm;
  }

  .chatbot-messages .prose p {
    @apply mb-2;
  }

  .chatbot-messages .prose p:last-child {
    @apply mb-0;
  }

  .chatbot-messages .prose h1,
  .chatbot-messages .prose h2,
  .chatbot-messages .prose h3,
  .chatbot-messages .prose h4 {
    @apply mb-2 mt-2;
  }

  .chatbot-messages .prose h1 {
    @apply text-lg;
  }

  .chatbot-messages .prose h2 {
    @apply text-base;
  }

  .chatbot-messages .prose h3 {
    @apply text-sm;
  }

  .chatbot-messages .prose h4 {
    @apply text-sm;
  }

  .chatbot-messages .prose ul,
  .chatbot-messages .prose ol {
    @apply mb-2;
  }

  .chatbot-messages .prose li {
    @apply mb-1;
  }

  .chatbot-messages .prose pre {
    @apply mb-2 mt-2 text-xs;
  }

  .chatbot-messages .prose blockquote {
    @apply my-2 mb-2;
  }

  .chatbot-messages .prose hr {
    @apply my-2;
  }

  .chatbot-messages .prose table {
    @apply mb-2 text-xs;
  }
</style>
